Assistente, o diagn√≥stico foi um sucesso. Os logs provaram que o erro √© um TypeError no fetch. Nossa miss√£o √© refatorar a fun√ß√£o handleSubmit para usar uma abordagem mais robusta e eficiente, com duas estrat√©gias de envio.
Sua Tarefa:
Substitua todo o conte√∫do da fun√ß√£o handleSubmit no arquivo src/App.tsx pelo c√≥digo a seguir. Este novo c√≥digo implementa a l√≥gica da "Dupla Ponte".
Generated typescript
// [Contexto: Em src/App.tsx, substitua a fun√ß√£o handleSubmit inteira por esta]

const handleSubmit = useCallback(async (e?: React.FormEvent | React.MouseEvent) => {
  if (e && typeof e.preventDefault === 'function') { e.preventDefault(); }

  const textToAnalyze = userText.trim();
  if (!selectedFile && !textToAnalyze) {
    alert("Por favor, forne√ßa um texto ou selecione um arquivo para an√°lise.");
    return;
  }
  if (loading) return;

  setLoading(true);
  setResult(null);
  
  let requestBody: FormData | string;
  let requestHeaders: HeadersInit = {};
  
  // --- L√ìGICA DA DUPLA PONTE ---
  if (selectedFile) {
    // PONTE 1: Carga Pesada (para arquivos)
    console.log("[DUPLA_PONTE] üöö Usando a Ponte de Carga (FormData) para arquivo.");
    const formData = new FormData();
    formData.append('file', selectedFile);
    formData.append('question', specificQuestion.trim());
    formData.append('analysis_mode', analysisMode);
    requestBody = formData;
    // Para FormData, o navegador define o Content-Type automaticamente.
  } else {
    // PONTE 2: Via Expressa (para texto)
    console.log("[DUPLA_PONTE] üö∂‚Äç‚ôÇÔ∏è Usando a Via Expressa (JSON) para texto.");
    const payload = {
      text: textToAnalyze,
      question: specificQuestion.trim(),
      analysis_mode: analysisMode,
    };
    requestBody = JSON.stringify(payload);
    requestHeaders['Content-Type'] = 'application/json';
  }
  
  console.log(`[CAIXA-PRETA] üïµÔ∏è Tentando iniciar a an√°lise. Endpoint: ${BACKEND_BASE_URL}/api/analyze`);

  try {
    const response = await fetch(`${BACKEND_BASE_URL}/api/analyze`, {
      method: 'POST',
      body: requestBody,
      headers: requestHeaders,
      mode: "cors"
    });

    console.log(`[CAIXA-PRETA] üåê Resposta da rede recebida. Status HTTP: ${response.status}`);

    if (!response.ok) {
      const errorText = await response.text().catch(() => 'N√£o foi poss√≠vel ler o corpo da resposta de erro.');
      throw new Error(`Erro de Servidor (${response.status}): ${errorText}`);
    }

    const data = await response.json();
    console.log("[CAIXA-PRETA] ‚ú® Resposta JSON parseada com sucesso:", data);
    
    if (data && data.displayData && data.displayData.humanized_text) {
      setResult({ ...data.displayData, verificationCode: data.displayData.verificationCode });
      setShowExport(true);
    } else if (data && data.error) {
      throw new Error(`Erro retornado pelo Backend: ${data.error}`);
    } else {
      throw new Error("Formato de resposta JSON inesperado.");
    }

  } catch (error: unknown) {
    console.error("[CAIXA-PRETA] üî¥ ERRO CR√çTICO CAPTURADO!");
    if (error instanceof Error) {
      console.error(`[CAIXA-PRETA] - Mensagem: ${error.message}`);
    } else {
      console.error("[CAIXA-PRETA] - Erro de tipo desconhecido:", error);
    }
    
    setResult({
      humanized_text: `Falha na An√°lise: ${(error instanceof Error) ? error.message : 'Ocorreu um erro desconhecido.'}`,
      verificationCode: undefined
    });

  } finally {
    setLoading(false);
    console.log("[CAIXA-PRETA] üèÅ Processo de an√°lise finalizado.");
  }
}, [userText, specificQuestion, loading, selectedFile, analysisMode]);